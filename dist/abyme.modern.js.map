{"version":3,"file":"abyme.modern.js","sources":["../src/abyme_controller.js"],"sourcesContent":["import { Controller } from 'stimulus';\n\nexport default class extends Controller {\n  // static targets = ['template', 'associations', 'fields', 'newFields'];\n  // Some applications don't compile correctly with the usual static syntax. \n  // Thus implementing targets with standard getters below\n\n  static targets = ['template', 'associations', 'fields', 'newFields']\n\n  connect() {\n    console.log(\"Abyme Connected\")\n\n    if (this.count) {\n      // If data-count is present,\n      // add n default fields on page load\n\n      this.add_default_associations();\n    }\n  }\n\n  // return the value of the data-count attribute\n\n  get count() {\n    return this.element.dataset.minCount || 0;\n  }\n  \n  // return the value of the data-position attribute\n  // if there is no position specified set end as default\n\n  get position() {\n    return this.associationsTarget.dataset.abymePosition === 'end' ? 'beforeend' : 'afterbegin';\n  }\n\n  // ADD_ASSOCIATION\n\n  // this function is call whenever a click occurs\n  // on the element with the click->abyme#add_association\n  // <button> element by default\n\n  // if a data-count is present the add_association\n  // will be call without an event so we have to check\n  // this case\n\n  // check for limit reached \n  // dispatch an event if the limit is reached\n\n  // - call the function build_html that take care\n  //   for building the correct html to be inserted in the DOM\n  // - dispatch an event before insert\n  // - insert html into the dom\n  // - dispatch an event after insert\n\n  add_association(event) {\n    if (event) {\n      event.preventDefault();\n    }\n\n    if (this.element.dataset.limit && this.limit_check()) {\n      this.create_event('limit-reached')\n      return false\n    }\n\n    const html = this.build_html();\n    this.create_event('before-add');\n    this.associationsTarget.insertAdjacentHTML(this.position, html);\n    this.create_event('after-add');\n  }\n\n  // REMOVE_ASSOCIATION\n\n  // this function is call whenever a click occurs\n  // on the element with the click->abyme#remove_association\n  // <button> element by default\n\n  // - call the function mark_for_destroy that takes care\n  //   of marking the element for destruction and hiding it\n  // - dispatch an event before mark & hide\n  // - mark for descrution + hide the element\n  // - dispatch an event after mark and hide\n\n  remove_association(event) {\n    event.preventDefault();\n\n    this.create_event('before-remove');\n    this.mark_for_destroy(event);\n    this.create_event('after-remove');\n  }\n\n  // LIFECYCLE EVENTS RELATED\n\n  // CREATE_EVENT\n\n  // take a stage (String) => before-add, after-add...\n  // create a new custom event \n  // and dispatch at at the controller level\n\n  create_event(stage, html = null) {\n    const event = new CustomEvent(`abyme:${stage}`, { detail: {controller: this, content: html} });\n    this.element.dispatchEvent(event);\n    // WIP\n    this.dispatch(event, stage);\n  }\n\n  // WIP : Trying to integrate event handling through controller inheritance\n  dispatch(event, stage) {\n    if (stage === 'before-add' && this.abymeBeforeAdd) this.abymeBeforeAdd(event);\n    if (stage === 'after-add' && this.abymeAfterAdd) this.abymeAfterAdd(event);\n    if (stage === 'before-remove' && this.abymeBeforeRemove) this.abymeBeforeAdd(event);\n    if (stage === 'after-remove' && this.abymeAfterRemove) this.abymeAfterRemove(event);\n  }\n\n  abymeBeforeAdd(event) {\n  }\n\n  abymeAfterAdd(event) {\n  }\n\n  abymeBeforeRemove(event) {\n  }\n\n  abymeAfterRemove(event) {\n  }\n\n  // BUILD HTML\n\n  // takes the html template and substitutes the sub-string\n  // NEW_RECORD for a generated timestamp\n  // then if there is a sub template in the html (multiple nested level)\n  // set all the sub timestamps back as NEW_RECORD\n  // finally returns the html  \n\n  build_html() {\n    let html = this.templateTarget.innerHTML.replace(\n      /NEW_RECORD/g,\n      new Date().getTime()\n    );\n      \n    if (html.match(/<template[\\s\\S]+<\\/template>/)) {\n      const template = html\n      .match(/<template[\\s\\S]+<\\/template>/)[0]\n      .replace(/(\\[\\d{12,}\\])(\\[[^\\[\\]]+\\]\"){1}/g, `[NEW_RECORD]$2`);\n      \n      html = html.replace(/<template[\\s\\S]+<\\/template>/g, template);\n    }\n\n    return html;\n  }\n  \n  // MARK_FOR_DESTROY\n\n  // mark association for destruction\n  // get the closest abyme--fields from the remove_association button\n  // set the _destroy input value as 1\n  // hide the element\n  // add the class of abyme--marked-for-destroy to the element\n\n  mark_for_destroy(event) {\n    let item = event.target.closest('.abyme--fields');\n    item.querySelector(\"input[name*='_destroy']\").value = 1;\n    item.style.display = 'none';\n    item.classList.add('abyme--marked-for-destroy')\n  }\n\n\n  // LIMIT_CHECK\n\n  // Check if associations limit is reached\n  // based on newFieldsTargets only\n  // persisted fields are ignored\n\n  limit_check() {\n    return (this.newFieldsTargets\n                .filter(item => !item.classList.contains('abyme--marked-for-destroy'))).length \n                >= parseInt(this.element.dataset.limit)\n  }\n\n  // ADD_DEFAULT_ASSOCIATION\n\n  // Add n default blank associations at page load\n  // call sleep function to ensure uniqueness of timestamp\n\n  async add_default_associations() {\n    let i = 0\n    while (i < this.count) {\n      this.add_association()\n      i++\n      await this.sleep(1);\n    }\n  }\n\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n"],"names":["Controller","connect","console","log","this","count","add_default_associations","element","dataset","minCount","position","associationsTarget","abymePosition","add_association","event","preventDefault","limit","limit_check","create_event","html","build_html","insertAdjacentHTML","remove_association","mark_for_destroy","stage","CustomEvent","detail","controller","content","dispatchEvent","dispatch","abymeBeforeAdd","abymeAfterAdd","abymeBeforeRemove","abymeAfterRemove","templateTarget","innerHTML","replace","Date","getTime","match","template","item","target","closest","querySelector","value","style","display","classList","add","newFieldsTargets","filter","contains","length","parseInt","[object Object]","i","sleep","ms","Promise","resolve","setTimeout","targets"],"mappings":"sDAE6BA,EAO3BC,UACEC,QAAQC,IAAI,mBAERC,KAAKC,OAIPD,KAAKE,2BAMAD,YACP,YAAYE,QAAQC,QAAQC,UAAY,EAM9BC,eACV,MAAyD,aAA7CC,mBAAmBH,QAAQI,cAA0B,YAAc,aAsBjFC,gBAAgBC,GAKd,GAJIA,GACFA,EAAMC,iBAGJX,KAAKG,QAAQC,QAAQQ,OAASZ,KAAKa,cAErC,OADAb,KAAKc,aAAa,oBAIpB,MAAMC,EAAOf,KAAKgB,aAClBhB,KAAKc,aAAa,cAClBd,KAAKO,mBAAmBU,mBAAmBjB,KAAKM,SAAUS,GAC1Df,KAAKc,aAAa,aAepBI,mBAAmBR,GACjBA,EAAMC,iBAENX,KAAKc,aAAa,iBAClBd,KAAKmB,iBAAiBT,GACtBV,KAAKc,aAAa,gBAWpBA,aAAaM,EAAOL,EAAO,MACzB,MAAML,EAAQ,IAAIW,YAAa,SAAQD,IAAS,CAAEE,OAAQ,CAACC,WAAYvB,KAAMwB,QAAST,KACtFf,KAAKG,QAAQsB,cAAcf,GAE3BV,KAAK0B,SAAShB,EAAOU,GAIvBM,SAAShB,EAAOU,GACA,eAAVA,GAA0BpB,KAAK2B,gBAAgB3B,KAAK2B,eAAejB,GACzD,cAAVU,GAAyBpB,KAAK4B,eAAe5B,KAAK4B,cAAclB,GACtD,kBAAVU,GAA6BpB,KAAK6B,mBAAmB7B,KAAK2B,eAAejB,GAC/D,iBAAVU,GAA4BpB,KAAK8B,kBAAkB9B,KAAK8B,iBAAiBpB,GAG/EiB,eAAejB,IAGfkB,cAAclB,IAGdmB,kBAAkBnB,IAGlBoB,iBAAiBpB,IAWjBM,aACE,IAAID,EAAOf,KAAK+B,eAAeC,UAAUC,QACvC,eACA,IAAIC,MAAOC,WAGb,GAAIpB,EAAKqB,MAAM,gCAAiC,CAC9C,MAAMC,EAAWtB,EAChBqB,MAAM,gCAAgC,GACtCH,QAAQ,mCAAqC,kBAE9ClB,EAAOA,EAAKkB,QAAQ,gCAAiCI,GAGvD,OAAOtB,EAWTI,iBAAiBT,GACf,IAAI4B,EAAO5B,EAAM6B,OAAOC,QAAQ,kBAChCF,EAAKG,cAAc,2BAA2BC,MAAQ,EACtDJ,EAAKK,MAAMC,QAAU,OACrBN,EAAKO,UAAUC,IAAI,6BAUrBjC,cACE,YAAakC,iBACAC,OAAOV,IAASA,EAAKO,UAAUI,SAAS,8BAA+BC,QACrEC,SAASnD,KAAKG,QAAQC,QAAQQ,OAQjBwC,iCAC5B,IAAIC,EAAI,EACR,KAAOA,EAAIrD,KAAKC,OACdD,KAAKS,kBACL4C,eACWC,MAAM,GAIrBA,MAAMC,GACJ,WAAWC,QAAQC,GAAWC,WAAWD,EAASF,OAxL7CI,QAAU,CAAC,WAAY,eAAgB,SAAU"}